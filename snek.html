<!doctype html>
<html>
    <head>
        <title>Hello, snake?</title>
        <style type="text/css">
            html, body { border: 0; margin: 0; padding: 2px; }
        </style>
    </head>
    <body>
        <canvas
          id="thingie"
          width="600"
          height="600"
          style="border: 7px inset black;">
            If you can see this, something has gone kablooie.
        </canvas>
        <p id="perf"></p>
        <p id="direction"></p>
        <p id="sneklen"></p>
    </body>
<script type="text/javascript">
"use strict";

// https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API

const canvas = document.getElementById('thingie');
/** @type CanvasRenderingContext2D */
const ctx = canvas.getContext('2d');

function lolrand(max) {
    return Math.floor(Math.random() * max);
}

const canvas_width = 600;
const canvas_height = 600;
const grid = [];

const grid_size = 60;
const grid_x = Math.floor(canvas_width / grid_size);
const grid_y = Math.floor(canvas_height / grid_size);
const background_color = '#abcdef';
const food_color = '#903060';
const grid_line_color = 'hsl(210, 75%, 79%)'; // #abcdef plus 7% sas, minus 1% lum

const snake_color = 'hsl(30, 14%, 44%)'; // #807060
const snake_hsl_body_start = 40;
const snake_hsl_body_end = 0;

const head_coords = [0, 0];
const food_coords = [1, 1];
const snake_coords = [ /* [y, x], [y, x], ... */ ];

const movement_speed = 500;
const growth_per_food = 2;
let grow_skip = 0;
let move_food = false;
let current_direction = 'ArrowRight';
let next_direction = 'ArrowRight';

let start_time = 0;
let last_time = 0;
let call_count = 0;
let last_draw = 0;
function game_loop(timestamp) {
    if (start_time == 0) {
        start_time = timestamp;
    }
    call_count++;

    if ( Math.floor(timestamp / 1000) > Math.floor(last_time / 1000) ) {
        document.getElementById('perf').textContent = call_count / (timestamp / 1000);
    }
    last_time = timestamp;

    if (timestamp > (last_draw + movement_speed)) {
        last_draw = timestamp;
        current_direction = next_direction;
        document.getElementById('direction').textContent = current_direction;

        if (current_direction == 'ArrowDown') {
            move_head(0, 1);
        } else if (current_direction == 'ArrowUp') {
            move_head(0, -1);
        } else if (current_direction == 'ArrowLeft') {
            move_head(-1, 0);
        } else if (current_direction == 'ArrowRight') {
            move_head(1, 0);
        }
        draw(timestamp);
    }

    window.requestAnimationFrame(game_loop);
}


function draw(timestamp) {
    // The snake has moved.  Let's clear out the grid and re-mark the current
    // snake positioning.  This could be done with more elegance instead of
    // just dumb brute force, but keeping it dumb part of the purpose.
    for (let y = 0; y < grid_y; y++) {
        for (let x = 0; x < grid_x; x++) {
            grid[y][x] = 0;
        }
    }

    for (const snake_coord of snake_coords) {
        grid[ snake_coord[0] ][ snake_coord[1] ] = 1;
    }

    if (move_food) {
        let new_food_x = lolrand(grid_x);
        let new_food_y = lolrand(grid_y);
        while (grid[ new_food_y ][ new_food_x ] != 0) {
            new_food_x = lolrand(grid_x);
            new_food_y = lolrand(grid_y);
        }
        food_coords[0] = new_food_y;
        food_coords[1] = new_food_x;
        move_food = false;
    }

    grid[ food_coords[0] ][ food_coords[1] ] = 2;

    // Brute force redraw the background and food
    for (let y = 0; y < grid_y; y++) {
        for (let x = 0; x < grid_x; x++) {
            if(grid[y][x] == 0) {
                ctx.fillStyle = background_color;
            } else if(grid[y][x] == 2) {
                ctx.fillStyle = food_color;
            }
            ctx.fillRect((x * grid_size) + 1, (y * grid_size) + 1, grid_size - 2, grid_size - 2);
        }
    }

    // But make the snake pretty.  The use of hsl() in the color lets us just
    // simply darken the original color to create a gradient.
    let lum_change = Math.max(snake_hsl_body_start, snake_hsl_body_end) - Math.min(snake_hsl_body_start, snake_hsl_body_end);
    let lum_change_per_unit = lum_change / snake_coords.length;
    let lum = snake_hsl_body_end;
    for (const snake_coord of snake_coords) {
        ctx.fillStyle = `hsl(30, 14%, ${lum}%)`;
        lum += lum_change_per_unit;

        ctx.fillRect((snake_coord[1] * grid_size) + 1, (snake_coord[0] * grid_size) + 1, grid_size - 2, grid_size - 2);
    }
    // The head always gets the base color.
    ctx.fillStyle = snake_color;
    ctx.fillRect((head_coords[1] * grid_size) + 1, (head_coords[0] * grid_size) + 1, grid_size - 2, grid_size - 2);

}

function init_grid() {

    // Create an empty grid
    let empty_x_list = [];
    for (let x = 0; x < grid_x; x++) {
        empty_x_list.push(0);
    }
    for (let y = 0; y < grid_y; y++) {
        grid.push(empty_x_list.slice());
    }

    // Place the head in the top half of the grid
    head_coords[0] = lolrand(Math.floor(grid_y / 2));
    head_coords[1] = lolrand(grid_x);
    grid[ head_coords[0] ][ head_coords[1] ] = 1;
    snake_coords.push(head_coords.slice());
    // and the food in the bottom half
    food_coords[0] = Math.floor(grid_y / 2) + lolrand(Math.floor(grid_y / 2));
    food_coords[1] = lolrand(grid_x);
    grid[ food_coords[0] ][ food_coords[1] ] = 2;

    // On each frame, we'll be coloring the squares created by these lines, but
    // not touching the lines themselves.  That means we can get away with only
    // drawing them once.
    for (let x = 0; x <= grid_x; x++) {
        ctx.beginPath();
        ctx.moveTo(x * grid_size, 0);
        ctx.lineTo(x * grid_size, canvas_width);
        ctx.lineWidth = 2;
        ctx.strokeStyle = grid_line_color;
        ctx.stroke();
        ctx.closePath();
    }

    for (let y = 0; y <= grid_y; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * grid_size);
        ctx.lineTo(canvas_width, y * grid_size);
        ctx.lineWidth = 2;
        ctx.strokeStyle = grid_line_color;
        ctx.stroke();
        ctx.closePath();
    }
}

function move_head(x, y) {
    grid[ head_coords[0] ][ head_coords[1] ] = 0;

    head_coords[0] += y;
    if (head_coords[0] >= grid_y) {
        head_coords[0] = 0;
    }
    if (head_coords[0] < 0) {
        head_coords[0] = grid_y - 1;
    }

    head_coords[1] += x;
    if (head_coords[1] >= grid_x) {
        head_coords[1] = 0;
    }
    if (head_coords[1] < 0) {
        head_coords[1] = grid_x - 1;
    }

    // The snake found the food => grow
    if (grid[ head_coords[0] ][ head_coords[1] ] == 2) {
        grow_skip += growth_per_food;
        move_food = true;
    }

    if (grow_skip > 0) {
        grow_skip--;
    } else {
        snake_coords.shift();
    }

    grid[ head_coords[0] ][ head_coords[1] ] = 1;
    snake_coords.push(head_coords.slice());

    document.getElementById('sneklen').textContent = snake_coords.length;
}

window.addEventListener('keydown', function (event) {
    if ((event.key == 'ArrowDown' && current_direction != 'ArrowUp')
        || (event.key == 'ArrowUp' && current_direction != 'ArrowDown')
        || (event.key == 'ArrowLeft' && current_direction != 'ArrowRight')
        || (event.key == 'ArrowRight' && current_direction != 'ArrowLeft')
    ) {
        next_direction = event.key;
    }
});

init_grid();
window.requestAnimationFrame(game_loop);

</script>
</html>
