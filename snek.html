<!doctype html>
<html>
    <head>
        <title>Hello, snake?</title>
        <style type="text/css">
            html, body { border: 0; margin: 0; padding: 2px; }
        </style>
    </head>
    <body>
        <canvas
          id="thingie"
          width="800"
          height="600"
          style="border: 7px inset black;">
            If you can see this, something has gone kablooie.
        </canvas>
        <p id="perf"></p>
    </body>
<script type="text/javascript">
"use strict";

// https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API

const canvas = document.getElementById('thingie');
/** @type CanvasRenderingContext2D */
const ctx = canvas.getContext('2d');

function lolrand(max) {
    return Math.floor(Math.random() * max);
}

const canvas_width = 800;
const canvas_height = 600;
const grid = [];

const grid_size = 20;
const grid_x = Math.floor(canvas_width / grid_size);
const grid_y = Math.floor(canvas_height / grid_size);
const background_color = '#abcdef';
const snake_color = '#807060';
const food_color = '#903060';
const grid_line_color = '#aaaaaa';

const head_coords = [0, 0];
const food_coords = [1, 1];
const snake_coords = [ /* [y, x], [y, x], ... */ ];

const growth_per_food = 10;
let grow_skip = 0;
let move_food = false;

let start_time = 0;
let last_time = 0;
let call_count = 0;
function draw(timestamp) {

    if (start_time == 0) {
        start_time = timestamp;
    }
    call_count++;

    if ( Math.floor(timestamp / 1000) > Math.floor(last_time / 1000) ) {
        document.getElementById('perf').textContent = call_count / (timestamp / 1000);
    }
    last_time = timestamp;

    // The snake has moved.  Let's clear out the grid and re-mark the current
    // snake positioning.  This could be done with more elegance instead of
    // just dumb brute force, but keeping it dumb part of the purpose.
    for (let y = 0; y < grid_y; y++) {
        for (let x = 0; x < grid_x; x++) {
            grid[y][x] = 0;
        }
    }

    for (const snake_coord of snake_coords) {
        grid[ snake_coord[0] ][ snake_coord[1] ] = 1;
    }

    if (move_food) {
        let new_food_x = lolrand(grid_x);
        let new_food_y = lolrand(grid_y);
        while (grid[ new_food_y ][ new_food_x ] != 0) {
            new_food_x = lolrand(grid_x);
            new_food_y = lolrand(grid_y);
        }
        food_coords[0] = new_food_y;
        food_coords[1] = new_food_x;
        move_food = false;
    }

    grid[ food_coords[0] ][ food_coords[1] ] = 2;

    // The correct thing to do here is to only redraw grid squares that have changed.
    // Let's not, though.
    for (let y = 0; y < grid_y; y++) {
        for (let x = 0; x < grid_x; x++) {
            if(grid[y][x] == 0) {
                ctx.fillStyle = background_color;
            } else if(grid[y][x] == 1) {
                ctx.fillStyle = snake_color;
            } else if(grid[y][x] == 2) {
                ctx.fillStyle = food_color;
            }
            ctx.fillRect((x * grid_size) + 1, (y * grid_size) + 1, grid_size - 2, grid_size - 2);
        }
    }

    window.requestAnimationFrame(draw);
}

function init_grid() {

    // Create an empty grid
    let empty_x_list = [];
    for (let x = 0; x < grid_x; x++) {
        empty_x_list.push(0);
    }
    for (let y = 0; y < grid_y; y++) {
        grid.push(empty_x_list.slice());
    }

    // Place the head in the top half of the grid
    head_coords[0] = lolrand(Math.floor(grid_y / 2));
    head_coords[1] = lolrand(grid_x);
    grid[ head_coords[0] ][ head_coords[1] ] = 1;
    snake_coords.push(head_coords.slice());
    // and the food in the bottom half
    food_coords[0] = Math.floor(grid_y / 2) + lolrand(Math.floor(grid_y / 2));
    food_coords[1] = lolrand(grid_x);
    grid[ food_coords[0] ][ food_coords[1] ] = 2;

    // On each frame, we'll be coloring the squares created by these lines, but
    // not touching the lines themselves.  That means we can get away with only
    // drawing them once.
    for (let x = 0; x <= grid_x; x++) {
        ctx.beginPath();
        ctx.moveTo(x * grid_size, 0);
        ctx.lineTo(x * grid_size, canvas_width);
        ctx.lineWidth = 2;
        ctx.strokeStyle = grid_line_color;
        ctx.stroke();
        ctx.closePath();
    }

    for (let y = 0; y <= grid_y; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * grid_size);
        ctx.lineTo(canvas_width, y * grid_size);
        ctx.lineWidth = 2;
        ctx.strokeStyle = grid_line_color;
        ctx.stroke();
        ctx.closePath();
    }
}

function move_head(x, y) {
    grid[ head_coords[0] ][ head_coords[1] ] = 0;

    head_coords[0] += y;
    if (head_coords[0] >= grid_y) {
        head_coords[0] = 0;
    }
    if (head_coords[0] < 0) {
        head_coords[0] = grid_y - 1;
    }

    head_coords[1] += x;
    if (head_coords[1] >= grid_x) {
        head_coords[1] = 0;
    }
    if (head_coords[1] < 0) {
        head_coords[1] = grid_x - 1;
    }

    // The snake found the food => grow
    if (grid[ head_coords[0] ][ head_coords[1] ] == 2) {
        grow_skip += growth_per_food;
        move_food = true;
    }

    if (grow_skip > 0) {
        grow_skip--;
    } else {
        snake_coords.shift();
    }

    grid[ head_coords[0] ][ head_coords[1] ] = 1;
    snake_coords.push(head_coords.slice());
}

window.addEventListener('keydown', function (event) {
    if (event.key == 'ArrowDown') {
        move_head(0, 1);
    } else if (event.key == 'ArrowUp') {
        move_head(0, -1);
    } else if (event.key == 'ArrowLeft') {
        move_head(-1, 0);
    } else if (event.key == 'ArrowRight') {
        move_head(1, 0);
    }
});

init_grid();
window.requestAnimationFrame(draw);

</script>
</html>
